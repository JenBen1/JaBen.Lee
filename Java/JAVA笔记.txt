第一行代码：
Public class HelloWorld{
	Public static void main(String[] args){
		System.out.println(“Hello World”);
}
}
Java标识符命名规则：
1、	由字母、数字、下划线（_）和美元符号（$）组成，不能以数字开头。
2、	区分大小、长度限制。
3、	不能是java中的关键字和保留关键字。
4、	标识符命名习惯：驼峰命名法、见名知意，以单词或单词组合来命名。
5、	类名由一个或多个单词组成，每个单词首字母大写。
6、	函数名、变量名由一个或多个单词组成，首单词首字母小写拼接词首字母大写。
7、	包名全小写，只可以使用特殊字符“.”,并且不易“.”开头或结尾。

Java变量、关键字、转义字符：

变量：内存空间、存储数据
酒店的房间：java的变量  房间的类型：java的数据类型
房间的门牌号：java的变量名 房间的住客：java 的值

声明：
数据类型  变量名；
Int a;
赋值：
变量名 = 值；
a= 100;
应用：
System.out.println(a);
注意：java是强类型语言，变量的类型必须与数据的类型一致
变量的定义方式：3种
先声明，再赋值：
数据类型  变量名;
变量名=值;

声明并赋值：
数据类型 变量名=值;

多个类型变量的声明与赋值：
数据类型 变量1,变量2,变量3=值3,变量4,变量5=值5;

关键字：
不能作为自定义的标识符使用

定义字符，必须用单引号括起来

Java采用了转义字符来表示单引号和一些特殊符号。
\n:换行
\r:回车
\t:水平制表
\\:代表一个反斜线字符”\”
\’代表一个单引号字符
\”代表一个双引号字符

数据类型：8种
Java中的数据类型：
基本数据类型：
整数：byte:-128-127 1字节 short:2字节 int:4字节 long:8字节
小数/浮点数：float:4字节   double：8字节
布尔类型：boolean: true/false  
字符类型：ASCLL码  Unicode 万国码 char:2字节 
引用数据类型： 字符串：String 任何””之间的字面值
基本类型转换：
强制类型转换： 

运算符：
1、算术运算符
2、赋值运算符
3、关系运算符
4、逻辑运算符
5、位运算符
6、卫衣运算符
7、三目运算符

基本if选择结构：
语法：
If(布尔表达式){
  	//代码块
}
执行流程：
对布尔表达式进行判断，结果为true，则先执行代码块，再执行后续代码。
结果为false，则跳过代码块，直接执行后续代码。
If else选择结构
语法：
If(布尔表达式){
	//代码块1
}else{
	//代码块2
}
执行流程:
对布尔表达式进行判断，
结果为true，则先执行代码块1，再退出整个结构，执行后续代码。
结果为false，则先执行代码块2，再退出整个结构，执行后续代码。

多重if选择结构
语法：
If(布尔表达式1){
	//代码块1
}else if(布尔表达式2){
	//代码块2
}else if(布尔表达式3){
	//代码块3
}else{
	//代码块4
}
执行流程：
表达式1为true,则执行代码块1，再退出整个结构，
表达式2为true,则执行代码块2，再退出整个结构，
表达式3为true,则执行代码块3，再退出整个结构，
以上均为false,则执行代码块4，再退出整个结构。
注意：
相互排斥，有一个为true,其他均不再执行，
适用区间判断，但要保证条件顺序（从大到小，从小到大）。

Switch分支结构语句：
语法：
Switch(变量|表达式){
	Case 值1：
		逻辑代码1；
	Case值2：
		逻辑代码2；
	Case值n：
		逻辑代码n;
		Default:
			为满足时的逻辑代码；
}
可判断的类型：
Byte,short,int,char,String
执行流程：如果变量中的值等于值1，则执行逻辑代码1；
如果变量中的值等于值2，则执行逻辑代码2；
如果变量中的值等于值n,则执行逻辑代码n;
如果变量中的值没有匹配的case值时，执行default中的逻辑代码。
注意：当匹配的case执行后，不会自动退出整个结构，而是继续向下执行，break关键字可在匹配的case执行后，跳出整个结构。适用等值判断。

嵌套if选择结构
语法：
If(外层表达式){
	If(内层表达式){
		//内层代码块1
}else {
		//内层代码块2
}
}else {
	//外层代码块
}

执行流程：
当外层条件满足时，再判断内层条件。
注意：
一个选择结构中，可嵌套另一个选择结构，嵌套格式正确的情况下，支持任意组合。

循环结构：3种
While循环：
语法：
While（布尔表达式）{
	//逻辑代码（循环操作）
}
执行流程：
先对布尔表达式进行判断，结果为true，则执行逻辑代码。
本次执行完毕后，再次进行判断，结果仍旧为true,则再次执行逻辑代码。
直至布尔表达式的结果为false时，才会退出循环结构，执行后续代码。
While的特点：
首次即有入口条件，先判断，再执行，适用于循环次数明确的情况

Do while 循环：
语法：
Do{
	逻辑代码（循环操作）
}while(布尔表达式);
执行流程：
先执行一次循环操作之后，再进行布尔表达式的判断。
如果结果为true，则再次执行循环操作。
如果结果为false，才会退出循环结构，执行后续代码。
特点：
先执行，再判断，适用于循环次数不明确的情况。
For 循环：
语法：
For(初始条件；循环条件；更新循环变量){
	//循环操作
}
执行流程：
首次执行初始部分（仅一次）。
对布尔表达式进行判断，结果为true,则执行逻辑代码。
本次执行完毕后，执行更新循环变量，再次判断，结果仍旧为true，则再次执行逻辑代码。
直至布尔表达式的结果为false时，才会退出循环结构，执行后续代码。

嵌套循环：
指的是循环之间的相互嵌套，被嵌套的称为内循环，嵌套内循环的称为外循环。
小组/选手	1号选手	2号选手	3号选手
1组	水瓶	天平	白羊
2组	双子	金牛	射手
3组	处女	狮子	摩羯
矩阵数据处理技巧：确定矩阵的行和列，外层循环控制行，内层循环控制列。

方法的定义：
概念：实现特定功能的一段代码，可反复使用。
定义语法：
Public static void 方法名称(){
	//方法体  逻辑代码
}
经验：将需要在多个位置重复使用的一组代码，定义在方法内部。

方法的参数：
多数情况下，方法与调用者之间需要数据的交互；调用者必须提供必要的参数，才能使方法完成相应的功能。

形参与实参：
定义语法：
Public static void 方法名称（形式参数）{
	//方法主体
}
形参：等价于局部变量的声明
调用语法：
方法名称（实际参数）；
实参：等价于局部变量的赋值
作用：方法的参数可以让代码功能更灵活、普适性更高，易于修改及其维护。

返回值与返回值类型
定义语法：
Public static 返回值类型 方法名称（形式参数列表）{
	//方法主体
	Return value;//返回值
}
调用语法：
返回值类型 变量=方法名称（）；//变量类型与返回值类型一致

Return 关键字：
Return的两种用法：
应用在具有返回值类型的方法中：
Return value;//表示结束当前方法，并伴有返回值，返回到方法调用处；
应用在没有返回值类型（void）的方法中：
Return；//表示结束当前方法，直接返回到方法调用处。

方法重载：overload
在类中可以创建多个方法，他们具有相同的名字，但具有不同的参数和不同的定义；返回值不能作为重载的条件。
例如：
Public static void method(int a){…}
Public static void method(char b){…}
递归：
什么是递归：解决具有既定规律的问题时，在方法内部再次调用自身方法的一种编程方式。
何时使用递归：当需要解决的问题可以拆分成若干个小问题，大小问题的解决方式相同，方法中自己调用自己。使用循环解决的常规问题，都可以替换为递归解决。
如何正确使用递归：
设置有效的出口条件，可以让调用链上的每个方法都可以正确返回，避免无穷递归。

2021.08.02

数组的概念：
一组连续的存储空间，存储多个相同数据类型的值：书架放书、彩笔盒装彩笔
特点：1、类型相同 2、长度固定
数组的遍历：从头到尾，逐一对数组的每个元素进行访问
数组名.length 可动态获得数组长度
数组默认值：
整数：0
小数：0
字符：|u0000
布尔:false
其他：null
数组创建方法：
先声明、再分配空间：
数据类型[] 数组名;
数组名=new 数据类型[长度];
声明并分配空间：
数据类型[] 数组名=new 数据类型[长度]；
分配内存空间并赋值：数组的大小就是赋值的个数声明并赋值：繁
数据类型[]数组名=new 数据类型 []{value1,value2,…};
声明并赋值：简单
数据类型[] 数组名={value1.value2,…};显示初始化，注意：不可换行
数组的扩容：创建比原来长度长的数组    复制过来新数组

数组的复制方式：//数组拷贝
1、System.arraycopy（原数组明，原数组的起始下标，新数组名，新数组起始下标，长度）
2、java.util.Arrays.copyOf(原数组，新长度)
数组类型的参数：
传递参数时：基本类型传递的是变量中的值，引用类型传递的是变量中的地址

二维数组：
多行多列

类与对象：
什么是程序：
程序是为了模拟现实世界，解决现实问题而使用计算机语言编写的指令集合。

什么是对象：
面向对象思想
一切客观存在的事物都是对象，万物皆对象；
任何对象，一定具有自己的特征和行为。
对象分为：
特征：称为属性，一般为名词，代表对象有什么。
行为：称为方法，一般为动词，代表对象能做什么。
类：设计图纸（模板）定义了对象应具有的特征和行为，类是对象的模板。不存在的

  对象：汽车（势力化）拥有多个特征和行为的实体，对象是类的实例。
类的抽象

类和对象的定义：
编写类  运行对象
类的定义：
属性：通过变量表示，又称实例变量
语法：数据类型 属性名；
位置：类的内部，方法的外部。
方法：通过方法表示，又称实例方法。
语法：public 返回值类型 方法名（形参）{
		//方法主体
}
注意：不再书写static，后面详解

2021.08.04
对象的定义格式：
1、	先声明对象，再创建对象
Horse qianLiMa = null;
qianLiMa = new Horse();

2、	声明并创建对象：
Horse hanXueBaoMa = new horse();

3、	匿名创建对象，并调用方法：
New Horse().printInfo();

New 关键字：1、创建对象2、实例化3、申请空间

对象的内存结构初探：
栈内存:基本数据类型直接在内存中  引用内存存储在内存的是地址
堆内存：地址指向堆内存空间  存储对象

引用类型赋值是赋值内存地址

什么是封装：
概念：尽可能隐藏对象的内部实现细节，控制对象的修改及访问的权限。
访问修饰符：private(可将属性修饰为私有，仅本类可见) 属性的封装
提供公共访问方法，以保证数据的正常录入。
命名规范：
赋值：setXXX()  //使用方法参数实现赋值
 setZxc(String zxc)
取值：getXXX() //使用方法返回值实现取值
 getZxc()
Get/set 方法
 
最后以访问的形式，进而完成赋值与取值操作。

封装有：属性的封装、方法的封装、类的封装、组件的封装、模块化封装、系统级封装等
封装的好处：模块化、信息隐藏、代码重用、具有安全性
封装缺点：影响执行效率

构造方法基本概念：
类中的特殊方法，主要用于创建对象。
特点：
名称与类名完全相同；
没有返回值类型；
创建对象时，触发构造方法的调用，不可通过句点手动调用。
注意：如果没有在类中显示定义构造方法，则编译器默认提供无参构造方法。
/**
 * 对象的创建过程：
 * 1、内存中开辟对象空间；
 * 2、为各个属性赋予初始值
 * 3、执行构造方法中的代码
 * 4、将对象的地址赋值给变量
 */

 
 
2021.08.05
This关键字：

Static关键字：
 
 

什么是静态：
概念：static 修饰符
静态（static）可以修饰属性和方法
使用static修饰的类属性，类方法称为静态属性，静态方法
静态成员是全类所有对象共享的成员
在全类只有一份，不因创建多个对象而产生多份。
不必创建对象，可直接通过类名访问。

类名.静态方法名
动态代码块/
静态代码块：类加载时，触发


 

 

 
2021.08.06
对象数组和管理：
对象数组：数组里的每个元素都是类的对象，赋值时先定义对象，然后将对象直接赋值给数组。
 

Java第二特性：继承
程序中的继承：
是类与类之间特征和行为的一种赠与或获得；
两个类之间的继承关系，必须满足“is a”（包含）的关系
父类要包含子类
狗是一种动物，一种生物，一种物质
父类的抽象：
可根据程序需要使用到的多个具体类，进行共性抽取，进而定义父类。
 
语法：
Class 子类名称  extends 父类名称{} //定义子类时，显示继承父类
应用：
产生继承关系后，子类可以使用父类中的属性和方法，也可以定义子类独有的属性和方法。
好处：
既可以提高代码的复用性，又可以提高代码的可扩展性。

Java为单继承，一个类只能有一个直接父类，但可以多级继承，属性和方法可以逐级叠加。

不可继承：
构造方法：类中的构造方法，只负责创建本类对象，不可继承。
Private修饰的属性和方法：访问修饰符的一种，仅本类可见。
父子类不在同一个package中时，default修饰的属性和方法：
访问修饰符的一种，仅同包可见。

2021.08.07
子类的实例化过程：
在子类进行实例化操作的时候，首先会先让其父类进行初始化操作，之后子类再自己进行实例化操作。
注意：所有的类都是Object类的直接或间接子类，Object类是所有类的父类。
子类：属性+方法  继承  父类：属性+方法

对象构建过程：
public class Objecttest {
    public static void main(String[] args) {
        StarDuck d =new StarDuck();
    }
}
class Animal{
    String name;
}
class Duck extends Animal{
    String color="白色";
    public Duck(){
        name="yaya";
    }
}
class StarDuck extends Duck{
    double fee;
    public StarDuck(){
        fee = 3000d;
    }
}
1、	JVM会读取指定路径下的StarDuck.class文件，并加载进内存，并会先加载StarDuck的父类（如果有直接的父类的情况下）

 
2、	在堆内存中开辟空间，分配地址

 
3、	并在对象空间中，对对象中的属性进行默认初始化。（不是显示初始化）

 
4、	调用对应的构造函数（构造方法）进行初始化

 
5、	在构造函数中，第一行会先调用父类的构造函数进行初始化，再对子类的属性进行初始化，初始化完毕后，将地址值赋值给引用变量

 

小结：
子类的实例化过程：
子类实例化时会先调用父类的构造方法，如果父类中没有默认的构造方法，在子类的构造方法中必须显示调用父类的构造方法
结论：
构造方法只是用于初始化类中的字段以及执行一些初始化代码
调用构造方法并不代表会生成对象
创建对象一定会调用构造方法。

方法的重写：
思考：
1、	子类中是否可以定义和父类相同的方法？可以。
2、	为什么需要在子类中定义和父类相同的方法？

重写原则：方法名称、参数列表、返回值类型必须与父类相同。访问修饰符可与父类相同或是比父类更宽泛。
方法重写的执行：
子类重写父类方法后，调用时优先执行子类重写后的方法。

Overloading和overrriding的区别：
重载：发生在同一个类里面的多个方法
重写：发生在子类跟父类当中  子类重写父类方法

Super:关键字
静态方法static 可以被子类继承但是不能被重写
Final关键字中的子类不允许被重写

Super关键字与this关键字都代表对象。Super关键字只能在存在继承关系的子类中出现，代表父类对象。
1、	super关键字出现在子类构造器中标识调用父类构造器。
2、	super关键字出现在子类方法中标识访问父类方法或属性。

抽象类的定义及抽象方法概述
Public abstract class Animal{
	Public abstract void run();//抽象方法
}
Abstract不能修饰静态方法
特点：
抽象类通常应包含抽象方法，也可以包含非抽象方法
抽象类不能使用final关键字修饰
抽象类自身不能够实例化，必需依赖子类进行创建
抽象类就是用来被继承的


抽象类的继承和创建：
抽象类被非抽象类继承必需对所有抽象方法提供实现。
抽象类被抽象类继承可以不实现抽象父类中的抽象方法，也可以对抽象方法进行实现。
抽象类对象的实例化必需通过非抽象子类进行创建。
抽象类对象都是上转型对象
Final修饰的方法不能在子类中被重写，抽象方法不能用final修饰。

接口和抽象类有什么区别：

相同点:
都可以定义抽象方法
都不可以实例化对象抽象方法
都要在子类中重写(实现),如果不全部重写,则子类也要定义为抽象类
不同点 :
1.意义不同             
a.抽象类是对对象的抽象          b.接口是实现功能的封装
2.  定义方式不同        
 a.抽象类用abstract修饰来定义         b.接口用interface替换class来定义
3.  内容不同       
  a.抽象类中除了抽象方法,还可以包含普通类中可以包含的成员         b.接口中除了抽象方法,jdk8中,接口还可以包含public static final修饰的常量,public static修饰的方法,public default修饰的方法.注意接口没有构造方法
4.  使用方式不同     
    a.抽象类用extend继承实现         b.接口需要被实现类implements实现5.  抽象类只支持单继承,接口可以多继承
6.  使用场景不同     
   a.如果只想拓展类的功能,优先选择接口       
 b.如果除了拓展功能外,还需要保存数据,只能选择抽象类;子类需要重写抽象类的方法,抽象类可以约束子类的某个功能

内部类的作用：
1、	内部类通过外部类访问从而被限定使用权限
2、	内部类所定义功能更多时候只为外部类提供
3、	内部类让某些功能使用更加安全

内部类的定义和创建：
内部类必需定义在某个类当中，所在类为其外部类
内部类可以使用public,protected,private访问修饰符
内部类可以使用abstract，final,static修饰符
内部类没有单独java源文件，只有class文件
内部类的类文件名称规范：外部类名$内部类名.class
//创建普通内部类：
Computer.Cpu cpu = new Computer().new Cpu();
//创建静态内部类：
Computer.Cpu cpu=new Computer.Cpu();
